using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEditor;
using UnityEditor.AddressableAssets;
using UnityEditor.AddressableAssets.Settings;
using UnityEngine;

namespace BS.Editor
{
    /// <summary>
    /// Addressable 설정이 변경될 때 각 Group 하위의 리소스 Asset Path를 상수 문자열로 자동 생성하는 에디터 유틸리티
    /// </summary>
    [InitializeOnLoad]
    public static class AddressableResourcePathConstantsGenerator
    {
        private const string ADDRESSABLE_CONSTANTS_FILE_PATH = "Assets/Scripts/AddressablePathConstants.cs";

        private static bool s_PendingGenerate;

        static AddressableResourcePathConstantsGenerator()
        {
            // Addressables 설정 변경 이벤트 구독
            AddressableAssetSettings.OnModificationGlobal += OnAddressablesModified;

            // 에디터 시작 시 한 번 생성(파일 없을 수 있음)
            EditorApplication.delayCall += () => SafeGenerate();
        }

        /// <summary>
        /// 메뉴에서 수동 실행
        /// </summary>
        [MenuItem("ProjectBS/Tools/Generate Addressable Path Constants")]
        public static void GenerateMenu()
        {
            GenerateConstantsFile();
            Debug.Log("Addressable Group Path Constants generated successfully!");
        }

        private static void OnAddressablesModified(AddressableAssetSettings settings, AddressableAssetSettings.ModificationEvent modificationEvent, object obj)
        {
            // 대부분의 변경 이벤트에서 재생성하도록 지연 호출로 디바운스
            SafeGenerate();
        }

        private static void SafeGenerate()
        {
            if (s_PendingGenerate)
                return;

            s_PendingGenerate = true;
            EditorApplication.delayCall += () =>
            {
                try
                {
                    GenerateConstantsFile();
                }
                finally
                {
                    s_PendingGenerate = false;
                }
            };
        }

        private class EntryInfo
        {
            public string Address;
            public string AssetPath;
        }

        /// <summary>
        /// Addressables 설정을 스캔하여 그룹별(재귀 포함) Asset Path 상수 파일 생성
        /// </summary>
        private static void GenerateConstantsFile()
        {
            var settings = AddressableAssetSettingsDefaultObject.Settings;
            if (settings == null)
            {
                // Addressables 미설정 프로젝트일 수 있음
                return;
            }

            var groupMap = new Dictionary<string, List<EntryInfo>>(StringComparer.Ordinal);

            foreach (var group in settings.groups.Where(g => g != null))
            {
                // 그룹 내 모든 엔트리를 재귀적으로 수집 (폴더 엔트리의 하위 포함)
                var collected = new List<AddressableAssetEntry>();

                // includeSelf: true, recurseAll: true, includeSubObjects: true 로 설정해 폴더 및 서브 오브젝트 포함
                group.GatherAllAssets(collected, includeSelf: true, recurseAll: true, includeSubObjects: true);

                // GUID 기준 중복 제거
                var seenGuids = new HashSet<string>(StringComparer.Ordinal);
                foreach (var entry in collected)
                {
                    if (entry == null)
                        continue;

                    var guid = entry.guid;
                    if (string.IsNullOrEmpty(guid) || !seenGuids.Add(guid))
                        continue;

                    var assetPath = AssetDatabase.GUIDToAssetPath(guid);
                    if (string.IsNullOrEmpty(assetPath))
                        continue;

                    var address = entry.address ?? string.Empty;

                    if (!groupMap.TryGetValue(group.name, out var list))
                    {
                        list = new List<EntryInfo>();
                        groupMap[group.name] = list;
                    }

                    list.Add(new EntryInfo
                    {
                        Address = address,
                        AssetPath = assetPath
                    });
                }
            }

            WriteConstantsFile(groupMap);
        }

        private static void WriteConstantsFile(Dictionary<string, List<EntryInfo>> groupMap)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// Auto-generated file. Do not modify manually.");
            sb.AppendLine("// This file is automatically generated from Addressables settings.");
            sb.AppendLine();
            sb.AppendLine("namespace BS.Common");
            sb.AppendLine("{");

            // 루트 컨테이너 클래스
            sb.AppendLine(" /// <summary>");
            sb.AppendLine(" /// Addressables Group 하위 Asset Path 상수 모음 (폴더/서브 에셋 포함)");
            sb.AppendLine(" /// </summary>");
            sb.AppendLine(" public static class AddressablePathConstants");
            sb.AppendLine(" {");

            foreach (var kvp in groupMap.OrderBy(k => k.Key, StringComparer.Ordinal))
            {
                var groupName = kvp.Key ?? string.Empty;
                var typeName = ConvertToTypeName(groupName);
                if (string.IsNullOrEmpty(typeName))
                    typeName = "GROUP"; // fallback

                sb.AppendLine(" /// <summary>");
                sb.AppendLine($" /// Group: {EscapeForComment(groupName)}");
                sb.AppendLine(" /// </summary>");
                sb.AppendLine($" public static class {typeName}");
                sb.AppendLine(" {");

                // 동일 그룹 내 상수명 충돌 방지
                var usedNames = new HashSet<string>(StringComparer.Ordinal);

                foreach (var e in kvp.Value.OrderBy(v => v.Address, StringComparer.Ordinal))
                {
                    var baseNameSource = string.IsNullOrEmpty(e.Address) ? Path.GetFileNameWithoutExtension(e.AssetPath) : e.Address;
                    var constName = ConvertToConstantName(baseNameSource);
                    if (string.IsNullOrEmpty(constName))
                        constName = "ASSET";

                    var uniqueName = constName;
                    int suffix = 1;
                    while (usedNames.Contains(uniqueName))
                    {
                        uniqueName = constName + "_" + suffix++;
                    }
                    usedNames.Add(uniqueName);

                    // 값은 실제 에셋 경로
                    sb.AppendLine($" public const string {uniqueName} = \"{e.AssetPath}\";");
                }

                sb.AppendLine(" }");
                sb.AppendLine();
            }

            sb.AppendLine(" }");
            sb.AppendLine("}");

            // 디렉터리 생성 보장
            var dir = Path.GetDirectoryName(ADDRESSABLE_CONSTANTS_FILE_PATH);
            if (!string.IsNullOrEmpty(dir) && !Directory.Exists(dir))
                Directory.CreateDirectory(dir);

            File.WriteAllText(ADDRESSABLE_CONSTANTS_FILE_PATH, sb.ToString());
            AssetDatabase.Refresh();

            // 로그 요약
            int groupCount = groupMap.Count;
            int entryCount = groupMap.Values.Sum(l => l?.Count ?? 0);
            Debug.Log($"Generated AddressablePathConstants.cs for {groupCount} groups with {entryCount} path constants");
        }

        /// <summary>
        /// 상수 이름 변환: 영숫자 외 문자는 '_'로, 소문자->대문자, 선행 숫자는 접두사 '_' 추가
        /// </summary>
        private static string ConvertToConstantName(string value)
        {
            if (string.IsNullOrEmpty(value))
                return string.Empty;

            var sb = new StringBuilder(value.Length * 2);
            for (int i = 0; i < value.Length; i++)
            {
                var c = value[i];
                if (char.IsLetterOrDigit(c))
                {
                    // 대소문자 경계에 '_' 추가 (abcdE -> ABCD_E)
                    if (i > 0 && char.IsUpper(c) && char.IsLetter(value[i - 1]) && char.IsLower(value[i - 1]))
                        sb.Append('_');

                    sb.Append(char.ToUpperInvariant(c));
                }
                else
                {
                    sb.Append('_');
                }
            }

            // 선행이 숫자면 접두 '_' 추가
            if (sb.Length > 0 && char.IsDigit(sb[0]))
                sb.Insert(0, '_');

            // 연속 '_' 축소
            var normalized = sb.ToString();
            while (normalized.Contains("__"))
                normalized = normalized.Replace("__", "_");

            return normalized.Trim('_');
        }

        /// <summary>
        /// 그룹명을 타입/클래스명으로 변환 (PascalCase), 선행 숫자 방지
        /// </summary>
        private static string ConvertToTypeName(string value)
        {
            if (string.IsNullOrEmpty(value))
                return string.Empty;

            var parts = new List<string>();
            var token = new StringBuilder();
            foreach (var ch in value)
            {
                if (char.IsLetterOrDigit(ch))
                {
                    token.Append(ch);
                }
                else
                {
                    if (token.Length > 0)
                    {
                        parts.Add(token.ToString());
                        token.Length = 0;
                    }
                }
            }
            if (token.Length > 0)
                parts.Add(token.ToString());

            var sb = new StringBuilder();
            foreach (var p in parts)
            {
                if (p.Length == 0) continue;
                var word = p.ToLowerInvariant();
                sb.Append(char.ToUpperInvariant(word[0]));
                if (word.Length > 1)
                    sb.Append(word.Substring(1));
            }

            var result = sb.ToString();
            if (string.IsNullOrEmpty(result))
                result = "Group";
            if (char.IsDigit(result[0]))
                result = "_" + result;
            return result;
        }

        private static string EscapeForComment(string s)
        {
            return s?.Replace("*/", "* /") ?? string.Empty;
        }
    }
}
